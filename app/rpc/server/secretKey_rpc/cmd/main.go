package main

import (
	"com.youyu.api/app/rpc/client"
	rpc "com.youyu.api/app/rpc/proto_files"
	"com.youyu.api/app/rpc/server/secretKey_rpc"
	"com.youyu.api/lib/config"
	logg "com.youyu.api/lib/log"
	"context"
	"github.com/go-redis/redis/v8"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"google.golang.org/grpc"
	"google.golang.org/grpc/keepalive"
	"io"
	"net"
	"os"
	"time"
)

func main() {
	var business config.Config = &config.BusinessConfig{}
	businessConf, err := business.GetConfig()
	// TODO:优化错误处理
	if err != nil {
		log.Panic().Err(err).Timestamp()
	}
	result := businessConf.(*config.BusinessConfig)
	// 从配置中心获取配置
	clientE, conn, err := client.GetCentApiRpcServerLink(result)
	if err != nil {
		log.Panic().Err(err).Timestamp()
	}
	defer conn.Close()
	// 通过Rpc连接日志中心
	stream, err := clientE.PushLogStream(context.Background())
	if err != nil {
		log.Panic().Err(err).Timestamp()
	}
	defer stream.CloseSend()
	logger := logg.Logger(&logg.ZLogger{
		Level: zerolog.ErrorLevel,
		Logger: zerolog.Logger{}.Output(io.MultiWriter(&client.IOW{
			CentRpcPushStream: stream,
			FileName:          "secretKey_rpc.log",
		}, os.Stdout)),
	})
	resultStruct, err := clientE.GetRpcServerConfFile(context.Background(), &rpc.Null{})
	if err != nil {
		logger.Panic(err)
	}
	app := config.Config(&config.AutoGenerated{})
	resultStruct, err = clientE.GetRpcServerConfFile(context.Background(), &rpc.Null{})
	if err != nil {
		logger.Panic(err)
	}
	appConf, err := app.Unmarshal(resultStruct.Data)
	if err != nil {
		logger.Panic(err)
	}
	appResult := appConf.(*config.AutoGenerated)
	// 注册签名密钥
	secretKey_rpc.TokenSigntureKey = []byte(appResult.Project.Auth.TokenSigntureKey)
	// TODO:重定向日志
	// 根据从配置中心获取的配置绑定ip
	listener, err := net.Listen("tcp", appResult.SecretKeyRPCServer.IP+":"+appResult.SecretKeyRPCServer.Port)
	if err != nil {
		logger.Panic(err)
	}
	// 初始化grpc设置
	grpc.MaxSendMsgSize(2 << 31)
	grpc.MaxRecvMsgSize(2 << 31)
	grpc.InitialWindowSize(2 << 29)
	grpc.InitialConnWindowSize(2 << 29)
	grpc.MaxConcurrentStreams(2 << 8)
	grpcServer := grpc.NewServer( // grpc超时连接设置
		grpc.KeepaliveParams(keepalive.ServerParameters{
			Time:    10,
			Timeout: 3,
		}))
	// 初始化redis连接池客户端
	redisClient := redis.NewClient(&redis.Options{
		// 网络连接方式
		Network: "tcp",
		// redis server地址
		Addr: appResult.Redis.IPAddr + ":" + appResult.Redis.Port,
		// redis的密码
		Password: appResult.Redis.Password,
		// 使用的数据库编号
		DB: 0,
		// 客户端建立连接的超时时间
		DialTimeout: time.Duration(appResult.Redis.Sync.DialTimeout) * time.Second,
		// 连接池的最大闲置连接数
		PoolSize: appResult.Redis.Sync.MaxOpenConnSize,
		// 连接池的最小保持的限制连接数量
		MinIdleConns: appResult.Redis.Sync.MinOpenConnSize,
		// 连接池连接的保活时间
		MaxConnAge: time.Duration(appResult.Redis.Sync.MaxConnLifeTime) * time.Second,
		// 当连接池中没有空闲连接时，程序等待空闲连接的最长时间
		PoolTimeout: time.Duration(appResult.Redis.Sync.PoolTimeout) * time.Second,
		// 闲置连接的超时时间
		IdleTimeout: time.Duration(appResult.Redis.Sync.IdleTimeout) * time.Second,
	})
	rpc.RegisterSecretKeyApiServer(grpcServer, &secretKey_rpc.SecretKeyApiServer{
		RedisClient: redisClient,
		Logger:      logger,
	})
	err = grpcServer.Serve(listener)
	if err != nil {
		logger.Panic(err)
	}
}
