package cent_rpc

import (
	rpc "com.youyu.api/app/rpc/proto_files"
	cf "com.youyu.api/lib/config"
	"com.youyu.api/lib/log"
	"com.youyu.api/lib/path"
	"com.youyu.api/lib/utils"
	"context"
	"encoding/json"
	"github.com/pkg/errors"
	"io"
	"os"
	"sync"
)

type CentApiServer struct {
	rpc.UnimplementedCentApiServer
	BusinessConfFile []byte
	RpcConfFile      []byte
	FilePathList     map[string]io.WriteCloser
	// ErrMsg的读写锁
	Lock sync.RWMutex
	// Config File的读写锁
	CfgLock sync.RWMutex
	// 日志接口
	Logger log.Logger
}

func (c *CentApiServer) GetBusinessConfFile(ctx context.Context, null *rpc.Null) (*rpc.Config, error) {
	c.CfgLock.RLock()
	defer c.CfgLock.RUnlock()
	return &rpc.Config{
		Type: "business_config",
		Data: c.BusinessConfFile,
	}, nil
}

func (c *CentApiServer) SetBusinessConfFile(ctx context.Context, config *rpc.Config) (*rpc.Null, error) {
	return &rpc.Null{}, setConfig(config.Type, config.Data)
}

func (c *CentApiServer) GetRpcServerConfFile(ctx context.Context, null *rpc.Null) (*rpc.Config, error) {
	c.CfgLock.RLock()
	defer c.CfgLock.RUnlock()
	return &rpc.Config{
		Type: "rpc_config",
		Data: c.RpcConfFile,
	}, nil
}

func (c *CentApiServer) SetRpcServerConfFile(ctx context.Context, config *rpc.Config) (*rpc.Null, error) {
	c.CfgLock.Lock()
	defer c.CfgLock.Unlock()
	err := setConfig(config.Type, config.Data)
	if err != nil {
		c.Logger.Error(errors.WithStack(err))
		return &rpc.Null{}, errors.WithStack(err)
	}
	_, err = c.FlushConfFile(ctx, &rpc.Null{})
	if err != nil {
		c.Logger.Error(err)
		return &rpc.Null{}, err
	}
	return &rpc.Null{}, nil
}

// FlushConfFile 刷新配置文件
func (c *CentApiServer) FlushConfFile(ctx context.Context, config *rpc.Null) (*rpc.Null, error) {
	businessResult, rpcResult, err := getConfig()
	if err != nil {
		c.Logger.Error(errors.Wrap(err, "flush conf file failed"))
		return &rpc.Null{}, err
	}
	c.BusinessConfFile = businessResult
	c.RpcConfFile = rpcResult
	return &rpc.Null{}, nil
}

func (c *CentApiServer) PushLogStream(server rpc.CentApi_PushLogStreamServer) error {
	// 检查存储日志文件path的map是否为空
	// 为空扫描目录的文件逐个添加
	for {
		result, err := server.Recv()
		if err == io.EOF {
			c.Logger.Error(errors.WithStack(err))
			return server.SendAndClose(&rpc.Null{})
		}

		if err != nil {
			c.Logger.Error(errors.WithStack(err))
			return err
		}
		// 获得文件对应的io.writer接口
		write := c.FilePathList[result.FileName]
		// 文件不存在则创建
		if write == nil {
			file, err := os.OpenFile(path.LogGlobalPath+"/"+result.FileName, os.O_SYNC|os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0755)
			if err != nil {
				c.Logger.Error(errors.WithStack(err))
				return err
			}
			// add
			c.FilePathList[result.FileName] = file
			write = c.FilePathList[result.FileName]
		}
		_, err = write.Write(result.Value)
		if err != nil {
			c.Logger.Error(errors.WithStack(err))
			return err
		}
	}
}

func (c *CentApiServer) GetErrMsgJsonBytes(ctx context.Context, null *rpc.Null) (*rpc.Info, error) {
	// 获取读锁
	c.Lock.RLock()
	// 释放读锁
	defer c.Lock.RUnlock()
	file, err := os.Open(path.InfoFileDefaultPath + "/" + path.ErrMsgJsonFileName)
	if err != nil {
		c.Logger.Error(errors.WithStack(err))
		return &rpc.Info{}, errors.WithStack(err)
	}
	defer file.Close()
	codesMap, err := utils.ReadErrJsonToCodesMap(io.Reader(file))
	if err != nil {
		c.Logger.Error(errors.WithStack(err))
		return &rpc.Info{}, errors.WithStack(err)
	}
	// json序列化
	codesJson, err := json.Marshal(codesMap)
	if err != nil {
		c.Logger.Error(errors.WithStack(err))
		return &rpc.Info{}, errors.WithStack(err)
	} else {
		return &rpc.Info{
			Type: path.ErrMsgJsonFileName,
			Data: codesJson,
		}, nil
	}
}

func (c *CentApiServer) SetErrMsgJson(ctx context.Context, info *rpc.Info) (*rpc.Null, error) {
	// 获取写锁
	c.Lock.Lock()
	// 释放写锁
	defer c.Lock.Unlock()
	// 写入文件
	if err := utils.WriteErrCodesMapToFile(info.Data, ""); err != nil {
		c.Logger.Error(errors.WithStack(err))
		return &rpc.Null{}, errors.WithStack(err)
	} else {
		return &rpc.Null{}, nil
	}
}

// 读取配置文件
func getConfig() ([]byte, []byte, error) {
	// 读取配置rpc配置
	var rpcConf cf.Config = &cf.AutoGenerated{}
	rpcConfig, err := rpcConf.GetConfig()
	if err != nil {
		return nil, nil, err
	}
	resultRpc := rpcConfig.(*cf.AutoGenerated)
	// 读取business配置
	var business cf.Config = &cf.BusinessConfig{}
	businessConf, err := business.GetConfig()
	if err != nil {
		return nil, nil, err
	}
	result := businessConf.(*cf.BusinessConfig)
	return result.Marshal(), resultRpc.Marshal(), nil
}

// 设置配置文件
func setConfig(tp string, data []byte) error {
	var conf cf.Config
	switch tp {
	case "rpc_config":
		conf = &cf.AutoGenerated{}
		break
	case "business_config":
		conf = &cf.BusinessConfig{}
		break
	}
	result, err := conf.Unmarshal(data)
	if err != nil {
		return err
	}
	err = conf.SetConfig(result)
	return err
}
